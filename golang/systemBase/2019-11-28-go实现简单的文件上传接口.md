# 本文目标
- 构建项目目录结构
- 实现一个简单的文件上传接口
- 讲解Demo所用的知识点

# 介绍和初始化项目

## 初始工作区
首先，我们需要增加一个工作区（GOPATH）路径用于我们的项目。

将你新的工作区加入到/etc/profile中的GOPATH环境变量中， 并在新工作区中，建立bin、pkg、src三个目录。

在src目录下创建FILESTORE-SERVER目录，初始的目录结构：
``` sh
$GOPATH
├── bin
├── pkg
└── src
    └── FILESTORE-SERVER
``` 

## 初始化项目目录	
``` sh
FILESTORE-SERVER/
├── handler
├── static
├── upload
├── main.go
``` 
- handler 业务逻辑处理
- static 存储静态的html文件
- upload 存储上传的文件

## 编写文件上传接口
在 handler目录下新建handler.go文件，写入文件内容：

1、handler.go:
``` sh
package handler

import (
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"os"
)

func UploadHandler(w http.ResponseWriter,r *http.Request)  {
	if r.Method=="GET" {
		data , err := ioutil.ReadFile("./static/view/index.html")

		if err !=nil {
			log.Fatal(err)
			io.WriteString(w,"inter error")
			return
		}

		io.WriteString(w,string(data))
	} else if r.Method=="POST"{
		//接收文件流及存储到本地目录
		file,head,err := r.FormFile("file")

		if err != nil {
			fmt.Printf("file upload fail ,err:%s\n",err.Error())
			return
		}

		defer file.Close()

		newFile,err := os.Create("./upload/"+head.Filename)
		if err != nil {
			fmt.Printf("file create fail ,err:%s\n",err.Error())
			return
		}

		defer newFile.Close()

		_,err = io.Copy(newFile,file)

		if err != nil {
			fmt.Printf("file copy fail ,err:%s\n",err.Error())
			return
		}

		io.WriteString(w,"upload success!!!")
	}
}

```
